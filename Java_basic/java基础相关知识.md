
## 目录
- [目录](#目录)
- [前言](#前言)
- [一、java语言的特点](#一java语言的特点)
- [二、JDK和JRE](#二jdk和jre)
- [三、8种基本数据类型](#三8种基本数据类型)
- [四、位运算符](#四位运算符)
- [五、接口和抽象类的区别](#五接口和抽象类的区别)
- [六、静态变量和实例变量的区别](#六静态变量和实例变量的区别)
- [七、浅拷贝和深拷贝的区别](#七浅拷贝和深拷贝的区别)
- [八、==和eqauls()的区别](#八和eqauls的区别)
- [九、final有哪些用法](#九final有哪些用法)
- [十、String对象的intern()](#十string对象的intern)
- [十一、String和StringBuffer的区别](#十一string和stringbuffer的区别)
- [十二、泛型的上界和下界](#十二泛型的上界和下界)

## 前言
大家好，我是苍何。最近思考了一个问题，为什么会出现公司面试造火箭，工作扭螺丝的现象，包括各种八股文的连环大绝杀问到你不会为主，其实这是考察你的知识面以及掌握的深度，而为什么需要这样呢？归其原因，无非是通过筛选找到那些会思考的人，他们需要的并不是CRUD的工具人，而是会思考能创新的工程师。

当你深刻理解到这点，我想不用刻意去学习，在工作中，肯定会吾日三省吾身。

于是乎，这个重新开始学习编程系列文章出来了。

愿与君共勉！

## 一、java语言的特点
**1、面向对象**
java语言是面向对象语言，他和面向过程C不同点是，有封装、继承、多态，万物皆是对象，但是执行效率面向过程稍微快些。
**2、垃圾回收**
JVM垃圾自动回收，即GC操作（后面会细讲）
**3、跨平台性**
一次编译，到处运行，其实JVM会针对不同不同有不同的实现，我们编写的代码会通过JVM转为.class字节码文件，字节码通过JVM可以在不同平台上运行，转化为能被不同平台识别的机器码。
## 二、JDK和JRE
**1、JDK是提供给java开发人员使用的开发工具包，包含了JRE**
**2、JRE是运行环境，包含了JVM**
## 三、8种基本数据类型
	
byte、short、int、long、float、double、char、boolean
## 四、位运算符
	1、<<(左移)
	向左移动n位，相当于乘以2的n次幂
	2、>>(右移)
	向左移动n位，相当于除以2的n次幂
	3、>>(无符号右移)
	被移位二进制最高位无论是0或者是1，空缺位都用0补

## 五、接口和抽象类的区别
1、访问修饰符
抽象类：public,protected和default等修饰
接口只能是：public
2、extends和implements
3、抽象类可以有构造器，接口不行
4、抽象类单根继承，接口多个实现
5、接口是约束定义规范，子类可以不实现父类所有方法，但是要实现接口里所有的方法
## 六、静态变量和实例变量的区别
静态变量存储在方法区,属于类所有.实例变量存储在堆当中,其引用存在当前线程栈.需要注意的是从JDK1.8开始用于实现方法区的PermSpace被MetaSpace取代了.

## 七、浅拷贝和深拷贝的区别
**1、浅拷贝：**
被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象。
构造方法和clone()方法都介意实现浅拷贝
**2、深拷贝：**
深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。
重写clone方法、通过对象序列化实现深拷贝
## 八、==和eqauls()的区别
1、基本数据类型：==是值比较
2、引用数据类型，==和equals都是比较内存地址，只不过有些类重写了Object类的equals方法，比如string类比较的就是值是否相等，重写equals需要重写hashcode方法
## 九、final有哪些用法
被final修饰的类不可以被继承
被final修饰的方法不可以被重写
被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
被final修饰的方法,JVM会尝试将其内联,以提高运行效率
被final修饰的常量,在编译阶段会存入常量池中.
除此之外,编译器对final域要遵守的两个重排序规则更好:

在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序
初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.

常见的final修饰类：

　　1、java.lang包中

　　　　包装类：Boolean，Character，Short，Integer，Long，Float，Double，Byte，Void(八大类型的包装类型加一个void)
　　　　字符串类：String，StringBuilder，StringBuffer
　　　　系统类：System、Math，StrictMath

　　2、java.util包中

　　　　UUID、Scanner

　　3、java.lang.reflect包中

　　　　Constructor、Field、Method

## 十、String对象的intern()
Stirng中的intern()是个Native方法,它会首先从常量池中查找是否存在该常量值的字符串,若不存在则先在常量池中创建,否则直接返回常量池已经存在的字符串的引用
## 十一、String和StringBuffer的区别
String和StringBuffer主要区别是性能:String是不可变对象,每次对String类型进行操作都等同于产生了一个新的String对象,然后指向新的String对象.所以尽量不要对String进行大量的拼接操作,否则会产生很多临时对象,导致GC开始工作,影响系统性能.

StringBuffer是对象本身操作,而不是产生新的对象,因此在有大量拼接的情况下,我们建议使用StringBuffer(线程安全).


## 十二、泛型的上界和下界
<?>: 无限制通配符
<? extends E>: extends 关键字声明了类型的上界,表示参数化的类型可能是所指定的类型,或者是此类型的子类
<? super E>: super关键字声明了类型的下界,表示参数化的类型可能是指定的类型,或者是此类型的父类
它们的目的都是为了使方法接口更为灵活,可以接受更为广泛的类型.

< ? extends E>: 用于灵活读取，使得方法可以读取 E 或 E 的任意子类型的容器对象。
< ? super E>: 用于灵活写入或比较,使得对象可以写入父类型的容器,使得父类型的比较方法可以应用于子类对象。
用简单的一句话来概括就是为了获得最大限度的灵活性,要在表示生产者或者消费者的输入参数上使用通配符,使用的规则就是:生产者有上限(读操作使用extends),消费者有下限(写操作使用super).

